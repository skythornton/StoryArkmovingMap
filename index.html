<!DOCTYPE html>
<html>
<head>
    <title>Story Ark Moving Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

    <style>
        body { margin:0; padding:0; }
        #map { width: 100%; height: 100vh; }
    </style>
</head>
<body>

<div id="map"></div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
    // Initialize the map centered on South Africa
    const map = L.map('map').setView([-29.5, 24], 6);

    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    // Car icon
    const carIcon = L.icon({
        iconUrl: 'storyark_car.png',  // <-- your custom image
        iconSize: [70, 30],           // <-- adjust size as needed
        iconAnchor: [35, 15]          // <-- adjust anchor to center bottom
    });

    // Marker (starts hidden)
    const marker = L.marker([0, 0], {icon: carIcon, opacity: 0}).addTo(map);

    // Fetch the GeoJSON route
    fetch('StoryArk_journey.json')
        .then(response => {
            if (!response.ok) throw new Error('Failed to load StoryArk_journey.geojson');
            return response.json();
        })
        .then(data => {
            const routeCoords = [];

            data.features.forEach(feature => {
                const geom = feature.geometry;

                if (geom.type === 'LineString') {
                    geom.coordinates.forEach(coord => {
                        routeCoords.push([coord[1], coord[0]]); // [lat, lon]
                    });
                }

                if (geom.type === 'MultiLineString') {
                    geom.coordinates.forEach(line => {
                        line.forEach(coord => {
                            routeCoords.push([coord[1], coord[0]]);
                        });
                    });
                }
            });

            if (routeCoords.length === 0) {
                throw new Error('No route coordinates found in GeoJSON');
            }

            // Draw the route line
            const routeLine = L.polyline(routeCoords, {color: 'red', weight: 4}).addTo(map);
            map.fitBounds(routeLine.getBounds());

            // Initialize marker at start
            marker.setLatLng(routeCoords[0]);
            marker.setOpacity(1);

            // Start smooth animation
            animateSmooth(routeCoords);
        })
        .catch(err => console.error('Error loading GeoJSON:', err));

    // Smooth animation function
    function animateSmooth(routeCoords) {
        let totalDistance = 0;
        const distances = [0];

        // Calculate cumulative distance between points
        for (let i = 1; i < routeCoords.length; i++) {
            const from = L.latLng(routeCoords[i - 1]);
            const to = L.latLng(routeCoords[i]);
            totalDistance += from.distanceTo(to);
            distances.push(totalDistance);
        }

        let progress = 0; // Progress along the route in meters
        const stepSize = 100; // Distance per frame in meters
        const animationSpeed = 1; // Delay between frames in ms

        function interpolatePosition(progress) {
            for (let i = 1; i < distances.length; i++) {
                if (progress <= distances[i]) {
                    const ratio = (progress - distances[i - 1]) / (distances[i] - distances[i - 1]);
                    const lat = routeCoords[i - 1][0] + (routeCoords[i][0] - routeCoords[i - 1][0]) * ratio;
                    const lng = routeCoords[i - 1][1] + (routeCoords[i][1] - routeCoords[i - 1][1]) * ratio;
                    return [lat, lng];
                }
            }
            return routeCoords[routeCoords.length - 1];
        }

        function step() {
            if (progress > totalDistance) {
                progress = 0; // Restart loop
            }

            const position = interpolatePosition(progress);
            marker.setLatLng(position);

            progress += stepSize;
            setTimeout(step, animationSpeed);
        }

        step();
    }
</script>

</body>
</html>
